    let conn_id = conn_stats.id();
    let conn_id = format!("Connection {conn_id}:");
    let new_active = gstat.active_conn_count();
    let laddr_clone = laddr.clone();
    let remote_address = socket.peer_addr().unwrap();
    'must_run: {
        let mut client_hello_buf = vec![0; 1024];
        let mut tls_client_hello_size = 0;
        let read_result = socket.read(&mut client_hello_buf).await;
        match read_result {
            Err(cause) => {
                error!("{conn_id} tls client hello read error");
                break 'must_run;
            },
            Ok(some_size) => {
                tls_client_hello_size = some_size;
            }
        }
        if tls_client_hello_size == 0 {
            error!("{conn_id} tls client hello read error");
            break 'must_run;
        }

        let tls_header_parsed = parse(&client_hello_buf[0..tls_client_hello_size]);
        let mut tlshost = String::from("");
        match tls_header_parsed {
            Err(cause) => {
                error!("{conn_id} tls client hello parse error: {cause}");
                break 'must_run;
            },
            Ok(some_value) => {
                tlshost = some_value.sni_host;
            }
        }

    
        let raddr = format!("{tlshost}:{rport}");
        let raddr_clone = raddr.clone();
        info!("{conn_id} ({new_active}) started: connecting to {laddr_clone}");
        let raddr_list = raddr.to_socket_addrs();
        for next_addr in raddr_list {
            let next_addr_ip = next_addr.ip();
            if is_address_in(next_addr_ip, &self_addresses) {
                error!("rejected self connection: {raddr}");
                ;
            }
        }
        let r_stream_r = TcpStream::connect(raddr).await;
        if let Err(cause) = r_stream_r.as_ref() {
            error!("{conn_id} failed to connect to {laddr_clone}, cause {cause}");
            break 'must_run;
        }
        let r_stream = r_stream_r.unwrap();
        let (mut lr, mut lw) = tokio::io::split(socket);
        let (mut rr, mut rw) = tokio::io::split(r_stream);

        let write_header_result = rw.write_all(&client_hello_buf[0..tls_client_hello_size]).await;
        match write_header_result {
            Err(cause) => {
                error!("failed to write client hello to remote: {cause}");
                break 'must_run;
            },
            _ => {

            }
        }
        // L -> R path
        let jh_lr = tokio::spawn( async move {
            let mut buf = vec![0; 4096];
            loop {
                let n = lr
                    .read(&mut buf)
                    .await
                    .expect("failed to read data from socket");
    
                if n == 0 {
                    return;
                }
    
                let write_result = rw
                    .write_all(&buf[0..n])
                    .await;
                match write_result {
                    Err(cause) => {
                        error!("failed to write data to socket: {cause}");
                        break;
                    },
                    Ok(_) => {
                        conn_stats1.add_uploaded_bytes(n);
                    }
                }
            }
        });

        // R -> L path
        let jh_rl = tokio::spawn(async move {
            let mut buf = vec![0; 4096];
            loop {
                let n = rr
                    .read(&mut buf)
                    .await
                    .expect("failed to read data from socket");
    
                if n == 0 {
                    return;
                }
    
                let write_result = lw
                    .write_all(&buf[0..n])
                    .await;
                match write_result {
                    Err(cause) => {
                        error!("failed to write data to socket: {cause}");
                        break;
                    },
                    Ok(_) => {
                        conn_stats2.add_downloaded_bytes(n);
                    }
                }
            }

        });
        jh_lr.await.unwrap();
        jh_rl.await.unwrap();
    }
    let elapsed = conn_stats.elapsed();
    let downloaded_final_v = conn_stats.downloaded_bytes();
    let uploaded_final_v = conn_stats.uploaded_bytes();
    local_gstats.add_downloaded_bytes(downloaded_final_v);
    local_gstats.add_uploaded_bytes(uploaded_final_v);
    let downloaded_final = ByteSize(downloaded_final_v as u64);
    let uploaded_final = ByteSize(uploaded_final_v as u64);

    let new_active = local_gstats.decrease_active_conn_count();
    info!("{conn_id} ({new_active}) stopped: Downloaded {downloaded_final} bytes, Uploaded {uploaded_final} bytes, Elapsed {elapsed:#?}")
